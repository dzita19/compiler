Parsing finished successfully.

Symtab: [
 Predefined types:
 void
 int8
 uint8
 int16
 uint16
 int32
  (*) to int32
  function(<nonprototype>) returning int32
  function(void) returning int32
 uint32
 int64
 uint64

 Scope: file [
  Obj: tag [
   Name: str1; Tag type: struct; Definition: defined; Size: 0x000C; Align: 0x0004
   Type: [
    struct str1: int32 x (0x0000), int32 y (0x0004), (*) to int32 p (0x0008)
   ]
  ]
  Obj: variable [
   Name: f; Address: 0x0000; Definition: defined; Storage: static; Linkage: external;
   Type: [function(<nonprototype>) returning int32]
  ]
  Obj: variable [
   Name: main; Address: 0x0018; Definition: defined; Storage: static; Linkage: external;
   Type: [function(void) returning int32]
  ]
  Scope: function prototype [
   Scope: block [
   ]
   Scope: function [
   ]
  ]
  Scope: function prototype [
   Scope: block [
    Obj: variable [
     Name: x; Address: 0x0004; Definition: defined; Storage: auto; Linkage: none;
     Type: [int32]
    ]
    Obj: variable [
     Name: y; Address: 0x0008; Definition: defined; Storage: auto; Linkage: none;
     Type: [int32]
    ]
    Obj: variable [
     Name: z; Address: 0x000C; Definition: defined; Storage: auto; Linkage: none;
     Type: [int32]
    ]
    Obj: variable [
     Name: p; Address: 0x0010; Definition: defined; Storage: auto; Linkage: none;
     Type: [(*) to int32]
    ]
    Obj: variable [
     Name: q; Address: 0x0014; Definition: defined; Storage: auto; Linkage: none;
     Type: [(*) to int32]
    ]
    Obj: variable [
     Name: r; Address: 0x0018; Definition: defined; Storage: auto; Linkage: none;
     Type: [(*) to int32]
    ]
    Scope: block [
    ]
   ]
   Scope: function [
   ]
  ]
 ]
]

Static objects list: [
]

String table: [
]

Translation unit ::
-Function body :: [FDEF] Name: f;
--Function prologue ::
--Function epilogue ::
-Function body :: [FDEF] Name: main;
--Function prologue ::
--If statement ::
---Not equals :: [RVAL] Type: int32; [LogicNode] JumpIfTrueId: 15; JumpIfFalseId: 19; Jump IF FALSE;
----Assign :: [RVAL] Type: int32;
-----Deref pointer :: [LVAL] Address: 0x0000; Type: int32;
------Address of :: [ADDR] Name: x; Address: 0x0000; Type: (*) to int32;
-----Constant :: [NUMLIT] Type: int32; Value: 0x0001;
----Constant :: [NUMLIT] Type: int32; Value: 0x0000;
---Compound statement ::
----Expression statement ::
-----Assign :: [RVAL] Type: int32;
------Deref pointer :: [LVAL] Address: 0x0000; Type: int32;
-------Address of :: [ADDR] Name: y; Address: 0x0000; Type: (*) to int32;
------Deref pointer :: [LVAL] Address: 0x0000; Type: int32;
-------Address of :: [ADDR] Name: z; Address: 0x0000; Type: (*) to int32;
--Function epilogue :: 19

Memory safety report: [
-Symtab: [
--Symtab          allocated =    1, freed =    1;
--Scope           allocated =    8, freed =    8;
--Obj             allocated =   12, freed =   12;
--Struct          allocated =    4, freed =    4;
--StaticVal       allocated =    0, freed =    0;
-]
-Utility: [
--LinkedList      allocated =    5, freed =    5;
--Node            allocated =   35, freed =   35;
--String          allocated =   15, freed =   15;
--Vector          allocated =    3, freed =    3;
--Array           allocated =    0, freed =    0;
-]
-Declarations: [
--TypeFrame       allocated =    4, freed =    4;
--NameFrame       allocated =    3, freed =    3;
--InitFrame       allocated =    0, freed =    0;
--ConstExpr       allocated =    0, freed =    0;
-]
-Statements: [
--TreeNode        allocated =   21, freed =   21;
--Tree            allocated =    1, freed =    1;
--Numlit          allocated =    1, freed =    1;
--ExprNode        allocated =   13, freed =   13;
-]
-Generating: [
--CallFrame       allocated =    0, freed =    0;
--ArgAlloc        allocated =    0, freed =    0;
--LogicNode       allocated =    1, freed =    1;
--StackAlloc      allocated =    0, freed =    0;
--MemAlloc        allocated =    0, freed =    0;
--AllocNode       allocated =    0, freed =    0;
--IrInstr         allocated =   19, freed =    0; <-- WARNING
-]
]

Semantic analysis successful.
